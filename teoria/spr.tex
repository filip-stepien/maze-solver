\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage[polish]{babel}
\usepackage{caption}
\usepackage[T1]{fontenc}
\usepackage{standalone}
\usepackage{fontawesome5}
\usepackage{geometry}
\usepackage{intcalc}
\usepackage{subcaption}
\usetikzlibrary{patterns}
\geometry{margin=2.5cm}
\title{
    \Huge Politechnika Świętokrzyska \\
    \large Wydział Elektrotechniki, Automatyki i Informatyki \\
    \vspace{0.5cm}
    \LARGE Dokumentacja projektu zespołowego \\
    \large Wizualizacja wyszukiwania drogi w labiryncie
}
\author{
  \begin{tabular}{c c}
    Filip Stępień & Rafał Grot \\
    \footnotesize Nr indeksu: 094117 & \footnotesize Nr indeksu: 094046 \\ \\
    \multicolumn{2}{c}{Informatyka, grupa 3ID11B} \\
  \end{tabular}
}
\date{\today}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Wstęp}

Celem projektu jest stworzenie aplikacji umożliwiającej generowanie dwuwymiarowego labiryntu oraz wizualizację procesu wyszukiwania ścieżki pomiędzy dwoma punktami.
Labirynt w kontekście projektu to struktura siatki, gdzie każde pole może stanowić przejście lub ścianę. 

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=0.8]
    \fill[gray] (1,2) rectangle ++(1,1);
    \fill[gray] (1,3) rectangle ++(1,1);
    \fill[gray] (3,1) rectangle ++(1,1);
    \fill[gray] (3,3) rectangle ++(1,1);
    \fill[gray] (1,1) rectangle ++(1,1);
    \fill[gray] (0,2) rectangle ++(1,1);
    \fill[gray] (3,0) rectangle ++(1,1);
    \fill[gray] (4,0) rectangle ++(1,1);
    
    \node at (0.5,1.5) {\tiny Start};
    \node at (4.5,1.5) {\tiny Koniec};
    \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
\end{tikzpicture}
\caption{\centering Przykładowy labirynt 5x5 z zaznaczonym startem i końcem, gdzie białe pole - przejście, czarne - ściana.}
\label{fig:labirynt}
\end{figure}

Można zauważyć, że taka struktura jest reprezentacją grafu, gdzie pola odpowiadają wierzchołkom, a krawędzie łączą sąsiadujące pola przejściowe.

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1, every node/.style={circle,draw,minimum size=10mm}]
  \node (n00) at (0,0) {};
  \node (n01) at (0,1.5) {\tiny Start};
  \node (n03) at (0,4.5) {};
  \node (n04) at (0,6) {};

  \node (n10) at (1.5,0) {};
  \node (n14) at (1.5,6) {};

  \node (n20) at (3,0) {};
  \node (n21) at (3,1.5) {};
  \node (n22) at (3,3) {};
  \node (n23) at (3,4.5) {};
  \node (n24) at (3,6) {};

  \node (n32) at (4.5,3) {};
  \node (n34) at (4.5,6) {};

  \node (n41) at (6,1.5) {\tiny Koniec};
  \node (n42) at (6,3) {};
  \node (n43) at (6,4.5) {};
  \node (n44) at (6,6) {};

  \draw (n00) -- (n01);
  \draw (n03) -- (n04);
  \draw (n04) -- (n14);
  \draw (n00) -- (n10);
  \draw (n10) -- (n20);
  \draw (n20) -- (n21);
  \draw (n21) -- (n22);
  \draw (n22) -- (n23);
  \draw (n23) -- (n24);
  \draw (n14) -- (n24);
  \draw (n24) -- (n34);
  \draw (n41) -- (n42);
  \draw (n42) -- (n43);
  \draw (n43) -- (n44);
  \draw (n22) -- (n32);
  \draw (n32) -- (n42);
  \draw (n34) -- (n44);
\end{tikzpicture}
\caption{Graf reprezentujący labirynt z rys. 1.}
\label{fig:graf_prim}
\end{figure}

W projekcie istotne jest porównanie różnych algorytmów wyszukiwania ścieżki, które pozwalają znaleźć trasę między dwoma punktami. W najlepszym przypadku celem jest znalezienie ścieżki \textit{optymalnej}, czyli takiej, która minimalizuje liczbę kroków, co w kontekście grafu o jednakowych wagach krawędzi sprowadza się do znalezienia drogi o minimalnej długości.

\newpage

\begin{figure}[ht]
  \centering
  \begin{subfigure}{0.4\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.8]
      \fill[gray] (1,2) rectangle ++(1,1);
      \fill[gray] (1,3) rectangle ++(1,1);
      \fill[gray] (3,1) rectangle ++(1,1);
      \fill[gray] (3,3) rectangle ++(1,1);
      \fill[gray] (1,1) rectangle ++(1,1);
      \fill[gray] (0,2) rectangle ++(1,1);
      \fill[gray] (3,0) rectangle ++(1,1);
      \fill[gray] (4,0) rectangle ++(1,1);

      \fill[pattern=north east lines, pattern color=green] (0,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (0,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (1,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,3) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,4) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (3,4) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,4) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,3) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,1) rectangle ++(1,1);

      \node at (0.5,1.5) {\tiny Start};
      \node at (4.5,1.5) {\tiny Koniec};

      \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{Ścieżka nieoptymalna}
  \end{subfigure}
  \begin{subfigure}{0.4\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.8]
      \fill[gray] (1,2) rectangle ++(1,1);
      \fill[gray] (1,3) rectangle ++(1,1);
      \fill[gray] (3,1) rectangle ++(1,1);
      \fill[gray] (3,3) rectangle ++(1,1);
      \fill[gray] (1,1) rectangle ++(1,1);
      \fill[gray] (0,2) rectangle ++(1,1);
      \fill[gray] (3,0) rectangle ++(1,1);
      \fill[gray] (4,0) rectangle ++(1,1);

      \fill[pattern=north east lines, pattern color=green] (0,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (0,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (1,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (3,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,1) rectangle ++(1,1);

      \node at (0.5,1.5) {\tiny Start};
      \node at (4.5,1.5) {\tiny Koniec};

      \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{Ścieżka optymalna}
  \end{subfigure}
  \caption{Porównanie ścieżek w labiryncie.}
  \label{fig:labirynt_optymalna_i_nieoptymalna_sciezka}
\end{figure}


\section{Generowanie labiryntu}

\subsection{Algorytm Prima}

Algorytm Prima to metoda generowania labiryntów wykorzystująca technikę tworzenia minimalnego drzewa rozpinającego (MST) dla grafu reprezentującego planszę labiryntu.
W kontekście generowania labiryntu działanie algorytmu przebiega następująco:

\begin{enumerate}
    \item Na początku tworzona jest plansza, w której wszystkie pola są oznaczone jako ściany.
    
    \begin{figure}[ht]
      \centering
      \begin{tikzpicture}[scale=0.8]
          \foreach \x in {0,...,4} {
              \foreach \y in {0,...,4} {
                  \fill[gray] (\x,\y) rectangle ++(1,1);
              }
          }
          \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
      \end{tikzpicture}
      \caption{\centering Cała plansza stanowi ściany.}
      \label{fig:prim_krok_11}
    \end{figure}

    \item Następnie wybierane jest losowe pole i oznaczane jako przejście.
    
    \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[scale=0.8]
        \foreach \x in {0,...,4} {
            \foreach \y in {0,...,4} {
                \fill[gray] (\x,\y) rectangle ++(1,1);
            }
        }
        \fill[white] (0, 0) rectangle ++(1,1);
        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{\centering Losowe pole startowe.}
    \label{fig:prim_losowe_pole_startowe}
    \end{figure}

    \clearpage

    \item Do zbioru krawędzi dodawane są sąsiednie komórki, do których można przejść bezpośrednio z miejsca startowego. Za sąsiednie uznaje się komórki oddalone o jedno pole w pionie lub poziomie.
    
    \begin{figure}[h]
    \centering
      \begin{tikzpicture}[scale=0.8]
          \foreach \x in {0,...,4} {
              \foreach \y in {0,...,4} {
                  \fill[gray] (\x,\y) rectangle ++(1,1);
              }
          }

          \fill[white] (0,2) rectangle ++(1,1);
          \fill[pattern=north east lines, pattern color=black] (0,2) rectangle ++(1,1);

          \fill[white] (2,0) rectangle ++(1,1);
          \fill[pattern=north east lines, pattern color=black] (2,0) rectangle ++(1,1);

          \fill[white] (0, 0) rectangle ++(1,1);

          \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
      \end{tikzpicture}
      \caption{\centering  Wybór sąsiednich pól.}
      \label{fig:prim_wybor_sasiadow}
    \end{figure}

    \item Losowana jest jedna krawędź ze zbioru. Jeśli prowadzi ona do nieodwiedzonego pola, to tworzy się przejście pomiędzy bieżącym polem a nowym (usuwana zostaje ściana między nimi), a nowe pole zostaje oznaczone jako przejście. Do zbioru krawędzi dodawani są sąsiedzi nowego pola.

    \begin{figure}[ht]
      \centering
      \begin{tikzpicture}[scale=0.8]
          \foreach \x in {0,...,4} {
              \foreach \y in {0,...,4} {
                  \fill[gray] (\x,\y) rectangle ++(1,1);
              }
          }

          \fill[white] (0,2) rectangle ++(1,1);
          \fill[pattern=north east lines, pattern color=black] (0,2) rectangle ++(1,1);

          \fill[white] (2,2) rectangle ++(1,1);
          \fill[pattern=north east lines, pattern color=black] (2,2) rectangle ++(1,1);

          \fill[white] (4,0) rectangle ++(1,1);
          \fill[pattern=north east lines, pattern color=black] (4,0) rectangle ++(1,1);


          \fill[white] (0, 0) rectangle ++(1,1);
          \fill[white] (2, 0) rectangle ++(1,1);
          \fill[white] (1, 0) rectangle ++(1,1);
          \draw[->, very thick, black] (0.5,0.5) -- (2.5,0.5);

          \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
      \end{tikzpicture}
      \caption{\centering Utworzenie krawędzi do sąsiedniego pola.}
      \label{fig:prim_utworzenie_krawedzi}
    \end{figure}

    \item Proces powtarza się, dopóki zbiór krawędzi nie będzie pusty.
    
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}[scale=0.8, every node/.style={circle,draw,minimum size=8mm}]
        \draw[very thick, black] (0.5,0.5) -- (2.5,0.5);
        \draw[very thick, black] (2.5,0.5) -- (2.5,4.5);
        \draw[very thick, black] (0.5,4.5) -- (4.5,4.5);
        \draw[very thick, black] (0.5,4.5) -- (0.5,2.5);
        \draw[very thick, black] (4.5,2.5) -- (4.5,0.5);
        \draw[very thick, black] (2.5,2.5) -- (4.5,2.5);

        \fill[gray] (0, 1) rectangle ++(1,1);
        \fill[gray] (1, 1) rectangle ++(1,1);
        \fill[gray] (1, 2) rectangle ++(1,1);
        \fill[gray] (1, 3) rectangle ++(1,1);
        \fill[gray] (3, 3) rectangle ++(1,1);
        \fill[gray] (4, 3) rectangle ++(1,1);
        \fill[gray] (3, 0) rectangle ++(1,1);
        \fill[gray] (3, 1) rectangle ++(1,1);

        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
      \end{tikzpicture}
      \caption{\centering Wyznaczanie kolejnych krawędzi labiryntu.}
      \label{fig:prim_kolejne_kroki_a}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
      \centering
      \begin{tikzpicture}[scale=0.8, every node/.style={circle,draw,minimum size=8mm}]
        \fill[gray] (0, 1) rectangle ++(1,1);
        \fill[gray] (1, 1) rectangle ++(1,1);
        \fill[gray] (1, 2) rectangle ++(1,1);
        \fill[gray] (1, 3) rectangle ++(1,1);
        \fill[gray] (3, 3) rectangle ++(1,1);
        \fill[gray] (4, 3) rectangle ++(1,1);
        \fill[gray] (3, 0) rectangle ++(1,1);
        \fill[gray] (3, 1) rectangle ++(1,1);

        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
      \end{tikzpicture}
      \caption{\centering Labirynt powstały na podstawie wyznaczonych krawędzi.}
      \label{fig:prim_kolejne_kroki_b}
    \end{subfigure}
    \caption{Kolejne kroki działania algorytmu.}
    \label{fig:prim_kolejne_kroki}
  \end{figure}

\end{enumerate}

Algorytm ten gwarantuje, że utworzony labirynt nie będzie zawierał zamkniętych pętli, a pomiędzy dowolnymi dwoma punktami zawsze będzie istniała możliwa ścieżka.

\clearpage

\subsection{Algorytm Kruskala}

Algorytm Kruskala podobnie jak algorytm Prima jest oparty na tworzeniu minimalnego drzewa rozpinającego. Algorytm traktuje ściany między polami labiryntu jako potencjalne krawędzie (przejścia w labiryncie). Działanie algorytmu w kontekście labiryntu przebiega następująco:

\begin{enumerate}
\item Na początku tworzona jest plansza, w której wszystkie pola są oznaczone jako przejśćia.

\item Tworzony jest zbiór rozłącznych zbiorów \textit{Disjoint Set}, w którym każda komórka należy do własnego zbioru — oznacza to, że na początku żadna komórka nie jest połączona z inną.

Struktura \textit{Disjoint Set} reprezentuje rozłączne zbiory elementów za pomocą drzew. Na początku każdy element tworzy pojedynczy, jednoelementowy zbiór, którego reprezentantem jest korzeń drzewa.

Kluczową operacją na tej strukturze jest \textit{Union}, która łączy dwa zbiory, tworząc jedno drzewo, w którym korzeń jednego zbioru staje się potomkiem korzenia drugiego. W ten sposób zbiory są scalane.

Schematyczne przedstawienie scalania zbiorów znajduje się na Rysunku \ref{fig:disjoint_set}.

\begin{figure}[ht]
  \centering

  \begin{subfigure}{0.24\textwidth}
    \centering
    \begin{tikzpicture}[scale=1, every node/.style={circle,draw,minimum size=8mm}]
      \node (n0) at (0,0) {1};
      \node (n1) at (1,0) {2};
      \node (n3) at (2,0) {3};
      \node (n4) at (3,0) {4};
    \end{tikzpicture}
    \caption{Krok 1}
    \label{fig:disjoint_set_a}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.24\textwidth}
    \centering
    \begin{tikzpicture}[scale=1, every node/.style={circle,draw,minimum size=8mm}]
      \node (n0) at (0,1.3) {1};
      \node (n1) at (0,0) {2};
      \node (n2) at (1,1.3) {3};
      \node (n3) at (2,1.3) {4};
      \draw[->, very thin, black] (0,0.4) -- (0,0.88);
    \end{tikzpicture}
    \caption{Krok 2}
    \label{fig:disjoint_set_b}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.24\textwidth}
    \centering
    \begin{tikzpicture}[scale=1, every node/.style={circle,draw,minimum size=8mm}]
      \node (n0) at (0,1.3) {1};
      \node (n1) at (0,0) {2};
      \node (n2) at (1,1.3) {3};
      \node (n3) at (1,0) {4};
      \draw[->, very thin, black] (0,0.4) -- (0,0.88);
      \draw[->, very thin, black] (1,0.4) -- (1,0.88);
    \end{tikzpicture}
    \caption{Krok 3}
    \label{fig:disjoint_set_c}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.24\textwidth}
    \centering
    \begin{tikzpicture}[scale=1, every node/.style={circle,draw,minimum size=8mm}]
      \node (n0) at (0.5,2.6) {1};
      \node (n1) at (0,1.3) {2};
      \node (n2) at (1,0) {3};
      \node (n3) at (1,1.3) {4};
      \draw[->, very thin, black] (0,1.7) -- (0.3,2.22);
      \draw[->, very thin, black] (1,1.7) -- (0.7,2.22);
      \draw[->, very thin, black] (1,0.4) -- (1,0.88);
    \end{tikzpicture}
    \caption{Krok 4}
    \label{fig:disjoint_set_d}
  \end{subfigure}

  \caption{Kolejne kroki scalania zbioru}
  \label{fig:disjoint_set}
\end{figure}
%https://cp-algorithms.com/data_structures/disjoint_set_union.html

\item Zbierane są wszystkie możliwe krawędzie, czyli miejsca między dwiema bezpośrednio sąsiadującymi komórkami, które można potencjalnie zamienić na ściany. Następnie są one tasowane w losowej kolejności. W odróżnieniu od algorytmu Prima, za sąsiadujące uznaje się tutaj pola przylegające bezpośrednio.

\item Iterujemy po każdej ścianie ze zbioru:
\begin{enumerate}
    \item Dla danej ściany sprawdzane są dwie komórki, które ta ściana oddziela.
    \item Jeśli te komórki należą do różnych zbiorów (nie są jeszcze połączone), to:
    \begin{enumerate}
      \item Usuwana jest ściana między nimi - tworzy się przejście.
      \item Obie komórki zostają połączone w jednym zbiorze.
    \end{enumerate}
    \item Jeśli komórki są już w tym samym zbiorze (czyli istnieje już droga między nimi), ściana nie jest usuwana — zapobiega to tworzeniu cykli.
\end{enumerate}

\item Proces trwa do momentu, gdy wszystkie komórki zostaną połączone w jeden zbiór — czyli zostanie utworzone jedno spójne drzewo bez cykli.
\end{enumerate}


% \section{Labirynt}

% \newcommand{\GridWidth}{8}   % liczba kolumn
% \newcommand{\GridHeight}{6}  % liczba wierszy

% Labirynt zbudownay jest z pól które reprezentują przejście lub ścianę.

% \begin{figure}[ht]
%   \begin{center}
%     \includestandalone{figures/maze_example}
%   \end{center}
%   \caption{Przykładowy labirynt}
% \end{figure}

% \faUser
% \faIcon{arrows-alt}

% \section{Generowanie labiryntu}
% \subsection{manual}
% \subsection{depth first search}
% \subsection{krushal}
% \subsection{Prim's}

% \section{Szukanie drogi}
% \subsection{depth first search}
% \subsection{breadth first search}
% \subsection{A*}


\end{document}