\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage[polish]{babel}
\usepackage{caption}
\usepackage[T1]{fontenc}
\usepackage{standalone}
\usepackage{fontawesome5}
\usepackage{geometry}
\usepackage{intcalc}
\usepackage{subcaption}
\usetikzlibrary{patterns}
\geometry{margin=2.5cm}
\title{
    \Huge Politechnika Świętokrzyska \\
    \large Wydział Elektrotechniki, Automatyki i Informatyki \\
    \vspace{0.5cm}
    \LARGE Dokumentacja projektu zespołowego \\
    \large Wizualizacja wyszukiwania drogi w labiryncie
}
\author{
  \begin{tabular}{c c}
    Filip Stępień & Rafał Grot \\
    \footnotesize Nr indeksu: 094117 & \footnotesize Nr indeksu: 094046 \\ \\
    \multicolumn{2}{c}{Informatyka, grupa 3ID11B} \\
  \end{tabular}
}
\date{\today}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Wstęp}

Celem projektu jest stworzenie aplikacji umożliwiającej generowanie dwuwymiarowego labiryntu oraz wizualizację procesu wyszukiwania ścieżki pomiędzy dwoma punktami.
Labirynt w kontekście projektu to struktura siatki, gdzie każde pole może stanowić przejście lub ścianę. 

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1]
    \fill[gray] (1,2) rectangle ++(1,1);
    \fill[gray] (1,3) rectangle ++(1,1);
    \fill[gray] (3,1) rectangle ++(1,1);
    \fill[gray] (3,3) rectangle ++(1,1);
    \fill[gray] (1,1) rectangle ++(1,1);
    \fill[gray] (0,2) rectangle ++(1,1);
    \fill[gray] (3,0) rectangle ++(1,1);
    \fill[gray] (4,0) rectangle ++(1,1);
    
    \node at (0.5,1.5) {\scriptsize Start};
    \node at (4.5,1.5) {\scriptsize Koniec};
    \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
\end{tikzpicture}
\caption{\centering Przykładowy labirynt 5x5 z zaznaczonym startem i końcem, gdzie białe pole - przejście, czarne - ściana.}
\label{fig:labirynt}
\end{figure}

Można zauważyć, że taka struktura jest reprezentacją grafu, gdzie pola odpowiadają wierzchołkom, a krawędzie łączą sąsiadujące pola przejściowe.

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1, every node/.style={circle,draw,minimum size=12mm}]
  \node (n00) at (0,0) {};
  \node (n01) at (0,1.5) {\scriptsize Start};
  \node (n03) at (0,4.5) {};
  \node (n04) at (0,6) {};

  \node (n10) at (1.5,0) {};
  \node (n14) at (1.5,6) {};

  \node (n20) at (3,0) {};
  \node (n21) at (3,1.5) {};
  \node (n22) at (3,3) {};
  \node (n23) at (3,4.5) {};
  \node (n24) at (3,6) {};

  \node (n32) at (4.5,3) {};
  \node (n34) at (4.5,6) {};

  \node (n41) at (6,1.5) {\scriptsize Koniec};
  \node (n42) at (6,3) {};
  \node (n43) at (6,4.5) {};
  \node (n44) at (6,6) {};

  \draw (n00) -- (n01);
  \draw (n03) -- (n04);
  \draw (n04) -- (n14);
  \draw (n00) -- (n10);
  \draw (n10) -- (n20);
  \draw (n20) -- (n21);
  \draw (n21) -- (n22);
  \draw (n22) -- (n23);
  \draw (n23) -- (n24);
  \draw (n14) -- (n24);
  \draw (n24) -- (n34);
  \draw (n41) -- (n42);
  \draw (n42) -- (n43);
  \draw (n43) -- (n44);
  \draw (n22) -- (n32);
  \draw (n32) -- (n42);
  \draw (n34) -- (n44);
\end{tikzpicture}
\caption{Graf reprezentujący labirynt z rys. 1.}
\label{fig:graf}
\end{figure}

W projekcie istotne jest porównanie różnych algorytmów wyszukiwania ścieżki, które pozwalają znaleźć trasę między dwoma punktami. W najlepszym przypadku celem jest znalezienie ścieżki \textit{optymalnej}, czyli takiej, która minimalizuje liczbę kroków, co w kontekście grafu o jednakowych wagach krawędzi sprowadza się do znalezienia drogi o minimalnej długości.

\newpage

\begin{figure}[ht]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=1]
      \fill[gray] (1,2) rectangle ++(1,1);
      \fill[gray] (1,3) rectangle ++(1,1);
      \fill[gray] (3,1) rectangle ++(1,1);
      \fill[gray] (3,3) rectangle ++(1,1);
      \fill[gray] (1,1) rectangle ++(1,1);
      \fill[gray] (0,2) rectangle ++(1,1);
      \fill[gray] (3,0) rectangle ++(1,1);
      \fill[gray] (4,0) rectangle ++(1,1);

      \fill[pattern=north east lines, pattern color=green] (0,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (0,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (1,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,3) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,4) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (3,4) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,4) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,3) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,1) rectangle ++(1,1);

      \node at (0.5,1.5) {\scriptsize Start};
      \node at (4.5,1.5) {\scriptsize Koniec};

      \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
  \end{minipage}
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=1]
      \fill[gray] (1,2) rectangle ++(1,1);
      \fill[gray] (1,3) rectangle ++(1,1);
      \fill[gray] (3,1) rectangle ++(1,1);
      \fill[gray] (3,3) rectangle ++(1,1);
      \fill[gray] (1,1) rectangle ++(1,1);
      \fill[gray] (0,2) rectangle ++(1,1);
      \fill[gray] (3,0) rectangle ++(1,1);
      \fill[gray] (4,0) rectangle ++(1,1);

      \fill[pattern=north east lines, pattern color=green] (0,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (0,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (1,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,0) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,1) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (2,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (3,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,2) rectangle ++(1,1);
      \fill[pattern=north east lines, pattern color=green] (4,1) rectangle ++(1,1);

      \node at (0.5,1.5) {\scriptsize Start};
      \node at (4.5,1.5) {\scriptsize Koniec};

      \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
  \end{minipage}
  \caption{\centering Porównanie ścieżek w labiryncie. Po lewej stronie – ścieżka nieoptymalna, po prawej – optymalna.}
  \label{fig:labirynt_optymalna_i_nieoptymalna_sciezka}
\end{figure}

\newcommand{\GridWidth}{8}   % liczba kolumn
\newcommand{\GridHeight}{6}  % liczba wierszy

\section{Generowanie labiryntu}

\subsection{Algorytm Prima}

Algorytm Prima to metoda generowania labiryntów wykorzystująca technikę tworzenia minimalnego drzewa rozpinającego (MST) dla grafu reprezentującego planszę labiryntu.
W kontekście generowania labiryntu działanie algorytmu przebiega następująco:

\begin{enumerate}
    \item Na początku tworzona jest plansza, w której wszystkie pola są oznaczone jako ściany.
    \item Następnie wybierane jest losowe pole i oznaczane jako przejście.
    \item Do zbioru krawędzi dodawane są sąsiednie pola, do których można przejść z wybranego pola.
    \item Losowana jest jedna krawędź ze zbioru. Jeśli prowadzi ona do nieodwiedzonego pola, to tworzy się przejście pomiędzy bieżącym polem a nowym (usuwana zostaje ściana między nimi), a nowe pole zostaje oznaczone jako przejście.
    \item Do zbioru krawędzi dodawani są sąsiedzi nowego pola. 
    \item Proces powtarza się, dopóki zbiór krawędzi nie będzie pusty.
\end{enumerate}

Algorytm ten gwarantuje, że wygenerowany labirynt nie będzie zawierał zamkniętych pętli, a pomiędzy dowolnymi dwoma punktami zawsze będzie istniała możliwa ścieżka. Charakteryzuje się ponadto dużą liczbą krótkich, ślepych zaułków, co w przypadku większych plansz znacząco utrudnia szybkie odnalezienie rozwiązania. Ilustracja działania algorytmu Prima została przedstawione na rysunkach 4-9.

\begin{figure}[ht]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=1]
        \foreach \x in {0,...,4} {
            \foreach \y in {0,...,4} {
                \fill[gray] (\x,\y) rectangle ++(1,1);
            }
        }
        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{\centering Krok 1. Cała plansza stanowi ściany.}
    \label{fig:prim_krok_1}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=1]
        \foreach \x in {0,...,4} {
            \foreach \y in {0,...,4} {
                \fill[gray] (\x,\y) rectangle ++(1,1);
            }
        }
        \fill[white] (0, 0) rectangle ++(1,1);
        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{\centering  Krok 2. Wybierane jest losowe pole startowe.}
    \label{fig:prim_krok_2}
  \end{minipage}
\end{figure}

\begin{figure}[ht]
  \centering
    \begin{minipage}{0.45\textwidth}
    \centering
        \begin{tikzpicture}[scale=1]
        \foreach \x in {0,...,4} {
            \foreach \y in {0,...,4} {
                \fill[gray] (\x,\y) rectangle ++(1,1);
            }
        }

        \fill[white] (0,2) rectangle ++(1,1);
        \fill[pattern=north east lines, pattern color=black] (0,2) rectangle ++(1,1);

        \fill[white] (2,0) rectangle ++(1,1);
        \fill[pattern=north east lines, pattern color=black] (2,0) rectangle ++(1,1);

        \fill[white] (0, 0) rectangle ++(1,1);

        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{\centering  Krok 3. Wybór sąsiednich pól, do których można poprowadzić krawędzie.}
    \label{fig:prim_krok_3}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[scale=1]
        \foreach \x in {0,...,4} {
            \foreach \y in {0,...,4} {
                \fill[gray] (\x,\y) rectangle ++(1,1);
            }
        }

        \fill[white] (0,2) rectangle ++(1,1);
        \fill[pattern=north east lines, pattern color=black] (0,2) rectangle ++(1,1);

        \fill[white] (2,2) rectangle ++(1,1);
        \fill[pattern=north east lines, pattern color=black] (2,2) rectangle ++(1,1);

        \fill[white] (4,0) rectangle ++(1,1);
        \fill[pattern=north east lines, pattern color=black] (4,0) rectangle ++(1,1);


        \fill[white] (0, 0) rectangle ++(1,1);
        \fill[white] (2, 0) rectangle ++(1,1);
        \fill[white] (1, 0) rectangle ++(1,1);
        \draw[->, very thick, black] (0.5,0.5) -- (2.5,0.5);

        \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
    \end{tikzpicture}
    \caption{\centering  Krok 4. Losowy wybór sąsiedniego pola i utworzenie nowej krawędzi.}
    \label{fig:prim_krok_4}
  \end{minipage}
\end{figure}

\begin{figure}[ht]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
        \begin{tikzpicture}[scale=1]
            \draw[very thick, black] (0.5,0.5) -- (2.5,0.5);
            \draw[very thick, black] (2.5,0.5) -- (2.5,4.5);
            \draw[very thick, black] (0.5,4.5) -- (4.5,4.5);
            \draw[very thick, black] (0.5,4.5) -- (0.5,2.5);
            \draw[very thick, black] (4.5,2.5) -- (4.5,0.5);
            \draw[very thick, black] (2.5,2.5) -- (4.5,2.5);

            \fill[gray] (0, 1) rectangle ++(1,1);
            \fill[gray] (1, 1) rectangle ++(1,1);
            \fill[gray] (1, 2) rectangle ++(1,1);
            \fill[gray] (1, 3) rectangle ++(1,1);
            \fill[gray] (3, 3) rectangle ++(1,1);
            \fill[gray] (4, 3) rectangle ++(1,1);
            \fill[gray] (3, 0) rectangle ++(1,1);
            \fill[gray] (3, 1) rectangle ++(1,1);

            \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
        \end{tikzpicture}
    \caption{\centering  Ilustracja kolejnych kroków wyznaczania krawędzi w algorytmie Prima.}
    \label{fig:prim_krok_5}
  \end{minipage}
  \hfill
  \begin{minipage}{0.45\textwidth}
    \centering
        \begin{tikzpicture}[scale=1]

            \fill[gray] (0, 1) rectangle ++(1,1);
            \fill[gray] (1, 1) rectangle ++(1,1);
            \fill[gray] (1, 2) rectangle ++(1,1);
            \fill[gray] (1, 3) rectangle ++(1,1);
            \fill[gray] (3, 3) rectangle ++(1,1);
            \fill[gray] (4, 3) rectangle ++(1,1);
            \fill[gray] (3, 0) rectangle ++(1,1);
            \fill[gray] (3, 1) rectangle ++(1,1);

            \draw[step=1cm,ultra thin,black] (0,0) grid (5,5);
        \end{tikzpicture}
    \caption{\centering Labirynt powstały na podstawie wyznaczonych krawędzi z~Rysunku 8.}
    \label{fig:prim_krok_6}
  \end{minipage}
\end{figure}


% \section{Labirynt}

% Labirynt zbudownay jest z pól które reprezentują przejście lub ścianę.

% \begin{figure}[ht]
%   \begin{center}
%     \includestandalone{figures/maze_example}
%   \end{center}
%   \caption{Przykładowy labirynt}
% \end{figure}

% \faUser
% \faIcon{arrows-alt}

% \section{Generowanie labiryntu}
% \subsection{manual}
% \subsection{depth first search}
% \subsection{krushal}
% \subsection{Prim's}

% \section{Szukanie drogi}
% \subsection{depth first search}
% \subsection{breadth first search}
% \subsection{A*}


\end{document}